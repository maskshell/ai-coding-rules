# 规则编写指南

本文档定义了如何为 Vibe Coding Rules 项目编写新的规则文件，确保规则的一致性、可维护性和实用性。

## 📋 目录

- [核心原则](#核心原则)
- [分层架构](#分层架构)
- [内容规范](#内容规范)
- [编写风格](#编写风格)
- [敏捷开发原则](#敏捷开发原则)
- [软件设计模式](#软件设计模式)
- [从完整版创建精简版规则](#从完整版创建精简版规则)
- [更新维护](#更新维护)
- [示例模板](#示例模板)
- [验收清单](#验收清单)
- [参考资料](#参考资料)

## 核心原则

### 1. 分层清晰

**四层架构，优先级自上而下递增：**

```text
IDE层（最通用）
  ↓ 优先级最低
语言层
  ↓
框架层
  ↓ 优先级最高
项目层
```

**规则**：下层的规则覆盖上层规则。

### 2. 职责单一

- 每个 `.cursor/coderules/` 目录只包含该类别的规则
- 不混合不同层次的规则
- 不重复其他层次的规则

### 3. 实用性优先

- 每条规则都应该解决具体问题
- 提供明确的示例和边界情况
- 避免模糊、主观的表述（如"代码应该很优雅"）

### 4. 渐进式采用

- 从预设模板开始，快速上手
- 根据项目需求逐步细化和定制
- 基于实际反馈持续优化

## 分层架构

### IDE 层（`full-rules/ide-layer/rulesets/`）

**适用范围**：所有项目、所有语言

**内容要求**：

- ✔ 通用编程原则（代码质量、可读性、错误处理）
- ✔ 跨语言的最佳实践
- ✔ AI 助手行为偏好
- ✔ 安全和测试规范
- ✘ 语言特定的语法规则
- ✘ 框架特定的模式

**典型文件**：

```text
01-general.md          # 通用编程规范
02-testing.md          # 测试规范
03-security.md         # 安全规范
04-ai-behavior.md      # AI行为偏好
...
```

**示例**：

```markdown
### 软件设计原则

- 设计新功能或重构时，寻找并应用该领域的最佳设计模式
- 使用经过验证的架构模式和最佳实践
- 保持模块低耦合、高内聚

### 开发流程原则

- 优先交付可工作的最小可行产品（MVP）
- 通过小步迭代和快速反馈验证想法
- 每个功能完成后立即进行基本测试
```

### 项目层（`full-rules/project-templates/{project}/`）

**适用范围**：特定类型的项目（React、Vue、Python等）

**目录结构**：

```text
full-rules/project-templates/react-app/
├── .cursor/
│   └── coderules/          # AI规则（每层2-3个文件）
│       ├── 01-react-basics.md
│       ├── 02-react-ui.md
│       └── ...
└── docs/
    └── coding-standards.md # 人类可读的完整规范
```

**AI规则内容要求**：

- ✔ 框架特定的编码规范
- ✔ 组件/模块设计模式
- ✔ 状态管理实践
- ✔ API调用约定
- ✔ 项目目录结构

**文档内容要求**：

- ✔ 详细的使用示例
- ✔ 完整的项目架构说明
- ✔ 开发流程和最佳实践
- ✔ 工具配置和调试指南

## 内容规范

### 规则文件命名

- 使用数字前缀（`01-`、`02-`）控制加载顺序
- 使用短横线分隔（`-`）
- 使用小写字母
- 文件名清晰描述内容

**示例**：

```text
Good:  01-react-basics.md, 02-react-hooks.md
Bad:   react.md, hooks.md, 01_ReactBasics.md
```

### 规则组织

每个 `.md` 文件应该有清晰的结构：

```markdown
# 标题

## 主要分类

### 子分类

- 具体规则
- 具体规则
```

### 规则表述

**DO（好的例子）**：

- 使用简洁、明确的指令
- 提供具体示例
- 说明规则的原因

```markdown
### 组件命名

- 文件名使用 PascalCase（`UserProfile.tsx`）
- 组件名与文件名一致

**原因**：保持一致性，便于文件搜索和导入。
```

**DON'T（不好的例子）**：

- 模糊的描述
- 没有示例
- 过于教条

```markdown
### 组件命名

- 组件应该有好的名字（模糊）
- 你必须按照这个规范来做（教条）
```

### 文件语言选择

**规则文档**：使用中文编写（目标用户是中国开发者）

**代码示例**：必须使用英语

- 代码中的标识符（变量名、函数名、类名）使用英语
- 技术术语保持英文原形（如 Custom Hooks、Repository Pattern）
- 代码注释可根据团队习惯选择语言
- 提供中英文混合示例时，清晰标注注释语言

**示例**：

````markdown
### 命名规范

- **所有标识符使用英语**：组件名、函数名、变量名等
- **避免拼音命名**：使用语义化英文单词
- **技术术语保持英文**：如 Hooks、Component 等
- **注释根据团队习惯选择**：可以使用中文或英文

**示例**：
```tsx
// Good: 英文命名，中文注释
/**
 * 用户资料卡片组件
 * @param user - 用户信息
 */
export function UserProfileCard({ user }: Props) {
  const [isLoading, setIsLoading] = useState(false); // 加载状态
  // ...
}
```
````

**原因**：

- 规则文档用中文：便于中国开发者阅读和理解
- 代码用英语：符合技术规范，AI生成效果更好（根据研究，英语代码生成成功率高出16-30%）
- 注释灵活选择：平衡可读性和团队习惯

## 编写风格

### 语气和态度

- **指导性，非强制性**：使用"优先..."而不是"必须使用..."
- **正面表述**：描述应该做什么，而不是不应该做什么
- **开放包容**：承认有多种正确的方式

**推荐**：

```markdown
- 优先使用函数组件 + Hooks
- 推荐使用 Context 管理简单状态
- 如果状态更复杂，考虑使用 Redux Toolkit
```

### 详细程度

**IDE 层**：高层次、抽象的指导

```markdown
### 代码质量

- 代码应该自解释
- 函数保持单一职责
```

**项目层**：具体操作步骤

```markdown
### 开发流程

1. 先实现基本功能
2. 添加类型验证
3. 优化用户体验
4. 编写测试
```

## 敏捷开发原则

### 如何表达敏捷思想

将敏捷原则转化为 AI 可执行的步骤：

**MVP 优先原则**：

```markdown
### 组件开发步骤

1. **先实现基本功能**：让组件能正常工作，完成核心需求
2. **添加类型和错误处理**：补充 TypeScript 类型，处理边界情况
3. **优化用户体验**：添加加载状态、错误提示等
4. **编写测试**：单元测试和集成测试
5. **代码审查和重构**：改善代码结构和可读性
```

**快速验证原则**：

```markdown
### 功能开发原则

- 每个功能完成后立即手动测试验证
- 优先交付可工作的最小功能增量
- 保持代码可随时发布的状态
```

**持续重构原则**：

```markdown
### 代码演进

- 先让代码工作，再让它干净，最后让它更快
- 通过重构改善代码质量，而不是一次做到完美
- 保持设计简单，需要时再引入复杂度
```

### 避免引入的内容

**不要包含**人类团队协作的流程：

```markdown
❌ 不要包含
- 每日站会
- Sprint 规划
- 回顾会议
- 故事点估算
```

这些不适合 AI 助手执行。

## 软件设计模式

### 如何表达设计模式指导

**IDE 层（抽象原则）**：

```markdown
### 软件设计原则

- 设计新功能或重构时，寻找并应用该领域的最佳设计模式
- 使用经过验证的架构模式和最佳实践
- 保持模块低耦合、高内聚
```

**项目层（具体应用）**：

```markdown
### 状态管理

- 小型应用使用 Context + useReducer（Reducer 模式）
- 中大型应用使用 Redux Toolkit（Flux 模式）
- 使用自定义 Hooks 封装可复用逻辑（Hooks 模式）
```

### 推荐模式示例

**React 项目**：

- 自定义 Hooks（Custom Hooks）
- 容器/展示组件（Container/Presentational）
- Reducer 模式

**Vue 项目**：

- Composables 模式
- Store 模式
- Provide/Inject 模式

**Python 后端**：

- Repository 模式
- Service 层模式
- 依赖注入（Dependency Injection）
- 工厂模式（Factory）

## 从完整版创建精简版规则

### 精简原则

**目标**：在保持核心指令不变的前提下，token 消耗减少 70-80%。

**核心策略**：

1. **删除解释性文字**：保留"做什么"，删除"为什么"的详细解释
2. **删除过多示例**：从 3-5 个示例减少到 1-2 个关键示例
3. **删除重复说明**：每个概念只保留最核心的表述
4. **使用简洁语法**：如用 `-` 列表替代段落文字
5. **保留结构**：数字前缀、标题层级保持不变

### 转换步骤

#### 步骤 1：分析完整版结构

**阅读完整版规则**，识别以下部分：

```text
完整版结构：
├── 标题和元数据（保留）
├── 详细解释（删除）
├── 多个示例（精简）
├── 背景说明（删除）
├── 注意事项（保留核心）
└── 参考链接（可选保留）
```

#### 步骤 2：转换内容

**对于每个章节**：

1. **保留标题层级**（`#`, `##`, `###`）数字前缀
2. **提取核心指令**（通常是列表项的第一句）
3. **删除修饰性文字**
4. **精简示例数量**
5. **保留代码示例结构**

**转换示例**：

完整版：

````markdown
### 组件命名

文件名使用 PascalCase（如 `UserProfile.tsx`）。使用这种命名方式的原因是保持一致性，便于在文件系统中搜索和识别组件。所有组件都应遵循此规范，以确保团队成员能够快速定位文件。

**原因**：保持一致性，便于文件搜索和导入。这个约定来自于社区最佳实践，被广泛应用于大型项目中。

**示例**:
```tsx
// Good - 清晰的命名
export function UserProfile() { ... }

export function ProductCard() { ... }

// Good - 描述组件用途
export function LoginForm() { ... }

// Bad - 使用下划线
export function user_profile() { ... }

// Bad - 太泛化
export function Card() { ... }
```

**注意事项**:

- 组件名应该清晰表达其用途
- 避免使用缩写，除非是通用缩写（如 `API`）
- 目录名可以使用 kebab-case 或 PascalCase，但在项目中保持一致

````

精简版：

````markdown
### 组件命名

- 文件名使用 PascalCase（如 `UserProfile.tsx`）
- 组件名与文件名保持一致
- 避免拼音命名，使用语义化英文

**示例**:
```tsx
// Good
export function UserProfile() { ... }

// Bad
export function user_profile() { ... }
```
````

#### 步骤 3：优化格式

**格式优化技巧**：

1. **使用紧凑列表**：

   ```markdown
   不使用：
   - 这是第一条规则。这条规则非常重要，因为...
   
   使用：
   - 这是第一条规则
   ```

2. **删除冗余标题**：

   ```markdown
   删除：
   ### 为什么使用这个规范
   
   保留：
   ### 命名规范
   - 理由：（合并到规则中）
   ```

3. **合并短规则**：

   ```markdown
   合并前：
   - 使用 PascalCase 命名
   - 保持一致性
   
   合并后：
   - 使用 PascalCase 命名，保持一致性
   ```

#### 步骤 4：验证精简结果

**检查清单**：

1. [ ] 保留了所有核心指令（AI 能正确执行）
1. [ ] 删除了 70-80% 的解释性文字
1. [ ] 示例数量从 3-5 个减少到 1-2 个
1. [ ] 结构保持一致（标题层级、数字前缀）
1. [ ] Token 数量确实大幅减少（90% → 20-30%）

**测试方法**：

1. 选择一个具体任务（如"创建一个用户登录组件"）
2. 让 AI 使用精简版规则生成代码
3. 比较生成结果与完整版是否一致
4. 如果不一致，检查是否删除了关键指令

### 转换对比表

| 要素 | 完整版 | 精简版 | 处理建议 |
|------|--------|--------|----------|
| 标题 | `# React 基础规范` | `# React 基础规范` | **保留** |
| 背景说明 | 200-300 字解释 | 删除 | **删除** |
| 规则描述 | 段落 + 解释 | 列表项 | **精简** |
| 示例数量 | 3-5 个 | 1-2 个 | **精简约 70%** |
| "为什么" | 详细解释 | 保留核心理由 | **精简到 1 句话** |
| 注意事项 | 多个要点 | 1-2 个关键要点 | **保留最重要的** |
| 参考链接 | 多个链接 | 可选保留 | **可选** |
| 总字数 | 500-800 字 | 100-150 字 | **减少 75-80%** |
| Token 消耗 | ~500-800 tokens | ~100-150 tokens | **减少 75-80%** |

### 常见转换模式

#### 模式 1：详细解释 → 简明列表

完整版：

```markdown
### 错误处理

在处理错误时，我们应该优先考虑用户体验。当有错误发生时，不应该让应用崩溃或者显示技术性的错误信息给用户看。相反，应该提供友好的错误提示。

**原因**：友好的错误提示可以减少用户的挫败感...
```

精简版：

```markdown
### 错误处理

- 提供友好的用户提示，避免技术性错误信息
- 防止应用崩溃
```

#### 模式 2：多个示例 → 1-2 个示例

完整版：

````markdown
**示例**:

```tsx
// 示例 1: 基础用法
function Example1() { ... }

// 示例 2: 带参数
function Example2(props) { ... }

// 示例 3: 完整场景
function Example3() {
  // 多行代码...
}
```
````

精简版：

````markdown
**示例**:

```tsx
// 基础用法
function Example(props) { ... }
```
````

#### 模式 3：章节合并

完整版：

```markdown
### 命名规范

文件名使用 PascalCase。

### 组件命名

组件名与文件名保持一致。

### 工具函数命名

工具函数使用 camelCase。
```

精简版：

```markdown
### 命名

- 文件名和组件：PascalCase（`UserProfile.tsx`）
- 工具函数：camelCase（`formatDate()`）
```

### 特殊处理

#### 必须保留的内容

1. **Context7 使用规则**：

   ```markdown
   精简版必须保留：

   ### Context7 使用
   
   在涉及第三方库时，自动使用 Context7 查询最新文档。
   
   **何时使用**：
   - 涉及第三方库的代码生成
   - 提供设置或配置步骤
   - 查询库/API 文档
   ```

2. **Critical 规则**：

   ```markdown
   完整版可能有很多解释，但精简版必须保留核心指令：

   ### 安全规范
   
   - 永不提交敏感信息（.env、API keys）
   - 验证用户输入，防止注入攻击
   ```

3. **数字顺序依赖的规则**：

   ```text
   如果规则有依赖关系（02 依赖 01），必须保留结构：
   01-general.md      # 基础概念
   02-advanced.md     # 高级用法（依赖基础）
   ```

#### 可以删除的内容

1. **详细背景**：原理、历史、社区讨论
2. **边缘案例**：不常见的边界情况
3. **重复说明**：在不同章节重复的内容
4. **主观评价**："优雅"、"漂亮"、"现代"等主观描述
5. **过长的参考链接**：保留 1-2 个最重要的

### 自动化工具（可选）

**未来可以开发**：

```bash
# 理想命令（尚未实现）
# 从完整版自动生成精简版
npm run convert-to-concise -- full-rules/ide-layer/01-general.md

# 输出：.concise-rules/ide-layer/01-general.md
```

**当前手动流程**：

````bash
   # 1. 复制完整版到精简版目录
        cp full-rules/ide-layer/rulesets/01-general.md .concise-rules/ide-layer/
   # 2. 手动精简内容（按本指南）
   # 3. 验证 Token 减少量
        # 使用工具计算 token 数量
````

## 更新维护

### 何时更新

**必须立即更新**：

- 新增项目模板时
- 有效讨论形成共识后（如本次讨论的设计模式、敏捷原则）
- 发现规则冲突或遗漏时

**应该定期更新**：

- 框架版本大变更时
- 最佳实践演进时
- 收到使用反馈后

### 更新流程

1. **记录变更**：在规则文件顶部添加更新记录

   ```markdown
   # React 基础规范
   
   **最后更新**: 2025-11-21
   **更新内容**: 添加 Composition API 规范
   ```

2. **评估影响**：检查变更是否影响其他规则
3. **同步更新**：更新相关文档和示例
4. **版本控制**：使用 Git 提交明确的更新日志

### 提交信息规范

使用 Conventional Commits 格式：

```text
feat: 添加 Vue 3 项目模板（新功能）
docs: 更新规则编写指南（文档）
refactor: 重组项目层目录结构（重构）
fix: 修正 React hooks 规则表述（修复）
```

## 示例模板

### 创建新语言/框架模板

**步骤**：

1. 在 `full-rules/project-templates/` 目录创建新项目文件夹
2. 创建标准目录结构：

   ```text
   new-framework-app/
   ├── .cursor/
   │   └── coderules/
   │       ├── 01-{framework}-basics.md
   │       └── 02-{framework}-advanced.md
   └── docs/
       └── coding-standards.md
   ```

3. 编写规则文件：
   - 参考现有模板的格式和专业度
   - 遵循本指南的所有规范
   - 提供清晰的示例和代码片段

4. 更新文档：
   - 在 README.md 中列出新的模板
   - 在规则编写指南中添加该框架的特点说明

### 规则文件模板

````markdown
# {技术栈} {主题} 规范

**适用范围**: {描述适用范围}

**最后更新**: {日期}

## 主要分类

### 子分类 1

- 规则 1
- 规则 2

**示例**:

```typescript
// 代码示例
```

## 主要分类 2

...

## 开发流程

### 开发步骤

1. 步骤 1
2. 步骤 2

### 功能开发原则

- 原则 1
- 原则 2

## 参考资源

- [官方文档](url)
- [最佳实践指南](url)

````

## 验收清单

创建或更新规则文件时，请检查：

- [ ] 遵循分层架构（不越层）
- [ ] 文件名符合命名规范（数字前缀、小写、短横线）
- [ ] 遵循内容规范（职责单一、有示例）
- [ ] 遵循编写风格（指导性、非强制性）
- [ ] 包含敏捷开发原则（MVP、快速验证、持续重构）
- [ ] 软件设计模式表述恰当（IDE层抽象、项目层具体）
- [ ] 提供清晰的代码示例
- [ ] 添加开发流程和步骤
- [ ] 更新 README.md（新项目模板）
- [ ] 更新本指南（新增通用原则）

## 参考资料

- [本文档的历史讨论记录](https://github.com/your-repo/discussions)
- 现有模板参考：
  - [React 模板](../full-rules/project-templates/react-app)
  - [Vue 模板](../full-rules/project-templates/vue-app)
  - [Python 后端模板](../full-rules/project-templates/python-backend)
  - [全栈模板](../full-rules/project-templates/fullstack-monorepo)
