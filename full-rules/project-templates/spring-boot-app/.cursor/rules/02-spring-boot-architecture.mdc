---
description: Spring Boot 架构设计
globs:
- '**/*'
alwaysApply: false
tags:
- general
version: 1.0.0
author: ai-coding-rules-team
---

# Spring Boot 架构设计

## 分层架构

### Request → Controller → Service → Repository → Database

- **Controller**：接收 HTTP 请求，参数验证，返回响应
- **Service**：业务逻辑，事务管理，调用 Repository
- **Repository**：数据访问，只包含 CRUD 操作
- **Entity**：JPA 实体类，映射数据库表
- **DTO**：数据传输对象，隔离内部和外部模型

**代码示例**:
```java
// Controller
@RestController
@RequestMapping("/api/v1/users")
@Validated
public class UserController {
    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/{id}")
    public ResponseEntity<Result<UserDTO>> getUser(@PathVariable @Min(1) Long id) {
        UserDTO user = userService.getUserById(id);
        return ResponseEntity.ok(Result.success(user));
    }

    @PostMapping
    public ResponseEntity<Result<UserDTO>> createUser(@Valid @RequestBody UserCreateDTO userDTO) {
        UserDTO createdUser = userService.createUser(userDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(Result.success(createdUser));
    }
}

// Service Interface
public interface UserService {
    UserDTO getUserById(Long id);
    UserDTO createUser(UserCreateDTO userCreateDTO);
    PageResult<UserDTO> getUsers(PageQuery pageQuery);
}

// Service Implementation
@Slf4j
@Service
@Transactional
public class UserServiceImpl implements UserService {
    private final UserRepository userRepository;
    private final UserMapper userMapper;

    public UserServiceImpl(UserRepository userRepository, UserMapper userMapper) {
        this.userRepository = userRepository;
        this.userMapper = userMapper;
    }

    @Override
    public UserDTO getUserById(Long id) {
        return userRepository.findById(id)
                .map(userMapper::toDTO)
                .orElseThrow(() -> new UserNotFoundException("用户不存在"));
    }

    @Override
    public UserDTO createUser(UserCreateDTO userCreateDTO) {
        if (userRepository.existsByUsername(userCreateDTO.getUsername())) {
            throw new UserAlreadyExistsException("用户名已存在");
        }

        User user = userMapper.toEntity(userCreateDTO);
        user.setPassword(BCrypt.hashpw(userCreateDTO.getPassword(), BCrypt.gensalt()));

        User savedUser = userRepository.save(user);
        log.info("创建新用户: {}", savedUser.getUsername());

        return userMapper.toDTO(savedUser);
    }
}

// Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    boolean existsByUsername(String username);
}

// DTO
@Data
public class UserCreateDTO {
    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 50, message = "用户名长度必须在3-50之间")
    private String username;

    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;

    @NotBlank(message = "密码不能为空")
    @Size(min = 8, message = "密码长度至少8位")
    private String password;
}
```

## RESTful API 设计

### URL 命名规范

- 使用复数名词：`/users`, `/products`, `/orders`
- 使用连字符分隔：`-`（推荐），避免下划线
- 版本号：`/api/v1/`, `/api/v2/`
- 嵌套资源：`/users/{id}/orders`
- 动作接口：如果无法使用 HTTP 方法表达，使用动词 `/users/{id}/change-password`

**示例**:
```java
@RestController
@RequestMapping("/api/v1/users")
public class UserController {
    @GetMapping
    public Result<List<UserDTO>> getAllUsers() { ... }

    @GetMapping("/{id}")
    public Result<UserDTO> getUser(@PathVariable Long id) { ... }

    @PostMapping
    public Result<UserDTO> createUser(@RequestBody UserCreateDTO user) { ... }

    @PutMapping("/{id}")
    public Result<UserDTO> updateUser(@PathVariable Long id, @RequestBody UserUpdateDTO user) { ... }

    @PatchMapping("/{id}")
    public Result<UserDTO> partialUpdateUser(@PathVariable Long id, @RequestBody Map<String, Object> updates) { ... }

    @DeleteMapping("/{id}")
    public Result<Void> deleteUser(@PathVariable Long id) { ... }

    @GetMapping("/{id}/orders")
    public Result<List<OrderDTO>> getUserOrders(@PathVariable Long id) { ... }
}
```

### 标准响应格式

```java
@Data
public class Result<T> {
    private int code;
    private String message;
    private T data;

    public static <T> Result<T> success(T data) {
        Result<T> result = new Result<>();
        result.setCode(200);
        result.setMessage("success");
        result.setData(data);
        return result;
    }

    public static <T> Result<T> success(String message, T data) {
        Result<T> result = new Result<>();
        result.setCode(200);
        result.setMessage(message);
        result.setData(data);
        return result;
    }

    public static <T> Result<T> error(int code, String message) {
        Result<T> result = new Result<>();
        result.setCode(code);
        result.setMessage(message);
        return result;
    }
}

// 分页结果
@Data
public class PageResult<T> {
    private long total;
    private int page;
    private int pageSize;
    private List<T> items;
}
```

## 异常处理

### 使用 @RestControllerAdvice 统一处理异常

```java
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    // 处理业务异常
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<Result<Void>> handleBusinessException(BusinessException ex) {
        log.warn("业务异常: {}", ex.getMessage());
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(Result.error(ex.getCode(), ex.getMessage()));
    }

    // 处理资源未找到异常
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Result<Void>> handleResourceNotFoundException(ResourceNotFoundException ex) {
        log.warn("资源未找到: {}", ex.getMessage());
        return ResponseEntity
                .status(HttpStatus.NOT_FOUND)
                .body(Result.error(404, ex.getMessage()));
    }

    // 处理参数验证异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Result<Map<String, String>>> handleValidationException(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error ->
            errors.put(error.getField(), error.getDefaultMessage())
        );
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(Result.error(400, "参数验证失败", errors));
    }

    // 处理所有未捕获的异常
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Result<Void>> handleException(Exception ex) {
        log.error("系统异常:", ex);
        return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Result.error(500, "服务器内部错误"));
    }
}

// 业务异常基类
public class BusinessException extends RuntimeException {
    private final int code;

    public BusinessException(int code, String message) {
        super(message);
        this.code = code;
    }

    public int getCode() {
        return code;
    }
}

// 自定义异常示例
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}

public class UserAlreadyExistsException extends BusinessException {
    public UserAlreadyExistsException(String message) {
        super(400, message);
    }
}
```

## Swagger API 文档

### 配置 Swagger

```java
@Configuration
@EnableSwagger2
public class SwaggerConfig {
    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.example.demo.controller"))
                .paths(PathSelectors.any())
                .build();
    }

    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("API 文档")
                .description("Spring Boot 项目 API 文档")
                .version("1.0")
                .build();
    }
}
```

### 在 Controller 中使用注解

```java
@RestController
@RequestMapping("/api/v1/users")
@Api(tags = "用户管理")
public class UserController {

    @GetMapping("/{id}")
    @ApiOperation("根据ID获取用户")
    @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long")
    @ApiResponses({
        @ApiResponse(code = 200, message = "成功", response = Result.class),
        @ApiResponse(code = 404, message = "用户不存在")
    })
    public ResponseEntity<Result<UserDTO>> getUser(@PathVariable Long id) {
        UserDTO user = userService.getUserById(id);
        return ResponseEntity.ok(Result.success(user));
    }
}
```

## 日志记录

### 使用 SLF4J + Logback

```java
@Slf4j
@Service
public class UserServiceImpl implements UserService {
    // 使用 @Slf4j 注解，自动生成 logger

    @Override
    public UserDTO createUser(UserCreateDTO userCreateDTO) {
        log.info("开始创建用户: username={}", userCreateDTO.getUsername());

        try {
            if (userRepository.existsByUsername(userCreateDTO.getUsername())) {
                log.warn("用户名已存在: {}", userCreateDTO.getUsername());
                throw new UserAlreadyExistsException("用户名已存在");
            }

            User user = userMapper.toEntity(userCreateDTO);
            User savedUser = userRepository.save(user);

            log.info("用户创建成功: id={}, username={}", savedUser.getId(), savedUser.getUsername());
            return userMapper.toDTO(savedUser);
        } catch (Exception e) {
            log.error("创建用户失败: username={}", userCreateDTO.getUsername(), e);
            throw e;
        }
    }
}
```

## 开发流程

### 开发步骤

1. **设计接口**：定义 API 路径、请求/响应格式
2. **创建 DTO**：定义请求和响应的数据结构
3. **实现 Controller**：处理 HTTP 请求和响应
4. **实现 Service**：编写业务逻辑，添加必要的验证
5. **实现 Repository**：定义数据访问接口
6. **处理异常**：在 Service 层抛出业务异常
7. **验证测试**：手动测试 API 功能
8. **添加测试**：编写单元测试和集成测试

### 功能开发原则

- Controller 层只做参数验证和响应封装
- Service 层负责业务逻辑和事务管理
- Repository 层只负责数据访问
- 每一层只与下一层交互，不跨层调用
- 使用 Mapper 进行 Entity 和 DTO 的转换
- 添加必要的日志记录，便于问题排查
