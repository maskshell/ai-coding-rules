---
description: Golang 架构设计规范
globs:
  - '**/*.go'
alwaysApply: false
tags:
  - golang
  - architecture
version: 1.0.0
author: ai-coding-rules-team
---

# Golang 架构设计规范

## 包组织

### 包设计原则

- 包应该提供单一、清晰的功能
- 包名应该简短、小写、有意义
- 避免循环依赖
- 使用 `internal` 包限制可见性

```go
// Good: 清晰的包职责
package user

type User struct {
    ID   int64
    Name string
}

func GetByID(id int64) (*User, error) {
    // ...
}

// Bad: 职责不清的包
package common  // 太泛化，不清楚具体功能
```

### 包可见性

- 公开的标识符首字母大写
- 私有的标识符首字母小写
- 使用 `internal` 目录限制包的外部访问

```go
// internal/user/user.go
package user

// 公开类型
type User struct {
    ID   int64
    Name string
}

// 私有类型
type userConfig struct {
    maxRetries int
}

// 公开函数
func GetByID(id int64) (*User, error) {
    // ...
}

// 私有函数
func validateUser(u *User) error {
    // ...
}
```

### 依赖管理

- 使用 Go Modules 管理依赖
- `go.mod` 文件定义模块和依赖版本
- 使用语义化版本控制依赖
- 定期更新依赖，修复安全漏洞

```go
// go.mod
module github.com/example/project

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    gorm.io/gorm v1.25.5
)

require (
    // 间接依赖
)
```

## 错误处理

### 错误类型

- 使用 `error` 接口表示错误
- 定义错误变量用于错误比较
- 创建自定义错误类型提供更多上下文

```go
import (
    "errors"
    "fmt"
)

// 错误变量
var (
    ErrUserNotFound    = errors.New("user not found")
    ErrInvalidInput     = errors.New("invalid input")
    ErrPermissionDenied = errors.New("permission denied")
)

// 自定义错误类型
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error on field %s: %s", e.Field, e.Message)
}

// 带堆栈信息的错误（使用 pkg/errors）
import "github.com/pkg/errors"

func GetUser(id int64) (*User, error) {
    user, err := db.FindUser(id)
    if err != nil {
        return nil, errors.Wrap(err, "failed to get user")
    }
    return user, nil
}
```

### 错误处理最佳实践

- 错误应该被处理，不要忽略
- 在函数边界处处理错误
- 使用 `errors.Is()` 检查特定错误
- 使用 `errors.As()` 提取错误类型
- 提供有意义的错误上下文

```go
// Good: 显式处理错误
func ProcessUser(id int64) error {
    user, err := GetUser(id)
    if err != nil {
        if errors.Is(err, ErrUserNotFound) {
            return fmt.Errorf("user %d not found", id)
        }
        return fmt.Errorf("failed to process user: %w", err)
    }
    
    // 处理用户
    return nil
}

// Bad: 忽略错误
func BadExample(id int64) {
    user, _ := GetUser(id)  // 错误被忽略
    // ...
}

// Good: 使用 errors.As 提取错误类型
func HandleError(err error) {
    var validationErr *ValidationError
    if errors.As(err, &validationErr) {
        fmt.Printf("Validation error on %s: %s\n", 
            validationErr.Field, validationErr.Message)
    }
}
```

## 接口设计

### 接口定义

- 接口应该小而专注
- 优先接受接口，返回结构体
- 接口名通常以 `-er` 结尾，或使用描述性名称
- 避免过度设计，只在需要时定义接口

```go
// Good: 小而专注的接口
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

// 组合接口
type ReadWriter interface {
    Reader
    Writer
}

// Good: 描述性接口名
type UserRepository interface {
    GetByID(ctx context.Context, id int64) (*User, error)
    Create(ctx context.Context, user *User) error
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id int64) error
}
```

### 接口实现

- 隐式实现：类型实现接口的所有方法即实现了接口
- 不需要显式声明实现关系
- 接口应该由使用者定义，而非实现者

```go
// 接口定义（在使用者包中）
package service

type UserRepository interface {
    GetByID(ctx context.Context, id int64) (*User, error)
}

// 实现（在实现者包中）
package repository

type userRepository struct {
    db *gorm.DB
}

func (r *userRepository) GetByID(ctx context.Context, id int64) (*User, error) {
    // 实现
}

// 隐式实现了 UserRepository 接口
```

## 并发编程

### Goroutines

- 使用 `go` 关键字启动 goroutine
- 注意 goroutine 的生命周期管理
- 避免 goroutine 泄漏

```go
// Good: 管理 goroutine 生命周期
func ProcessTasks(tasks []Task) {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    for _, task := range tasks {
        go func(t Task) {
            if err := processTask(ctx, t); err != nil {
                log.Printf("Error processing task: %v", err)
            }
        }(task)
    }
}

// Bad: goroutine 泄漏
func BadExample() {
    go func() {
        for {
            // 无限循环，无法取消
        }
    }()
}
```

### Channels

- 使用 channel 在 goroutine 间通信
- 明确 channel 的方向（发送、接收、双向）
- 使用 `close()` 关闭 channel，接收方检查 channel 是否关闭

```go
// Good: 使用 channel 通信
func ProcessData(data []int) []int {
    ch := make(chan int, len(data))
    
    // 发送数据
    go func() {
        defer close(ch)
        for _, v := range data {
            ch <- v * 2
        }
    }()
    
    // 接收数据
    var result []int
    for v := range ch {
        result = append(result, v)
    }
    
    return result
}

// Good: 明确 channel 方向
func sender(ch chan<- int) {
    ch <- 1
}

func receiver(ch <-chan int) {
    v := <-ch
    fmt.Println(v)
}
```

### 同步原语

- 使用 `sync.Mutex` 保护共享资源
- 使用 `sync.RWMutex` 实现读写锁
- 使用 `sync.WaitGroup` 等待 goroutine 完成
- 使用 `sync.Once` 确保只执行一次

```go
import "sync"

// Mutex
type SafeCounter struct {
    mu    sync.Mutex
    value int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

// RWMutex
type Cache struct {
    mu   sync.RWMutex
    data map[string]interface{}
}

func (c *Cache) Get(key string) (interface{}, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    value, ok := c.data[key]
    return value, ok
}

// WaitGroup
func ProcessConcurrently(items []Item) {
    var wg sync.WaitGroup
    for _, item := range items {
        wg.Add(1)
        go func(i Item) {
            defer wg.Done()
            processItem(i)
        }(item)
    }
    wg.Wait()
}

// Once
var once sync.Once

func Initialize() {
    once.Do(func() {
        // 只执行一次
    })
}
```

### Context

- 使用 `context.Context` 传递请求范围的值和取消信号
- 作为函数第一个参数传递
- 使用 `context.WithCancel`、`context.WithTimeout`、`context.WithDeadline` 创建派生 context

```go
import "context"

// Context 作为第一个参数
func GetUser(ctx context.Context, id int64) (*User, error) {
    // 检查取消
    select {
    case <-ctx.Done():
        return nil, ctx.Err()
    default:
    }
    
    // 执行操作
    return fetchUser(ctx, id)
}

// 使用 WithTimeout
func ProcessWithTimeout() error {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    return Process(ctx)
}

// 传递 context
func Handler(ctx context.Context, id int64) {
    user, err := GetUser(ctx, id)
    if err != nil {
        // 处理错误
    }
}
```

## 设计模式

### 依赖注入

- 通过构造函数或方法参数注入依赖
- 使用接口而非具体类型
- 提高可测试性和灵活性

```go
// Good: 依赖注入
type UserService struct {
    repo UserRepository
    logger Logger
}

func NewUserService(repo UserRepository, logger Logger) *UserService {
    return &UserService{
        repo:   repo,
        logger: logger,
    }
}

func (s *UserService) GetUser(id int64) (*User, error) {
    s.logger.Info("Getting user", "id", id)
    return s.repo.GetByID(context.Background(), id)
}

// Bad: 硬编码依赖
type BadUserService struct {
    db *gorm.DB  // 直接依赖具体实现
}
```

### Repository 模式

- 使用 Repository 模式封装数据访问逻辑
- 定义接口，提供具体实现
- 便于测试和切换数据源

```go
// Repository 接口
type UserRepository interface {
    GetByID(ctx context.Context, id int64) (*User, error)
    Create(ctx context.Context, user *User) error
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id int64) error
}

// 数据库实现
type dbUserRepository struct {
    db *gorm.DB
}

func NewDBUserRepository(db *gorm.DB) UserRepository {
    return &dbUserRepository{db: db}
}

func (r *dbUserRepository) GetByID(ctx context.Context, id int64) (*User, error) {
    var user User
    if err := r.db.WithContext(ctx).First(&user, id).Error; err != nil {
        return nil, err
    }
    return &user, nil
}

// 内存实现（用于测试）
type memoryUserRepository struct {
    users map[int64]*User
}

func NewMemoryUserRepository() UserRepository {
    return &memoryUserRepository{
        users: make(map[int64]*User),
    }
}
```

### Service 层

- Service 层封装业务逻辑
- 协调 Repository 和其他服务
- 处理业务规则和验证

```go
type UserService struct {
    repo   UserRepository
    logger Logger
}

func NewUserService(repo UserRepository, logger Logger) *UserService {
    return &UserService{
        repo:   repo,
        logger: logger,
    }
}

func (s *UserService) CreateUser(ctx context.Context, req CreateUserRequest) (*User, error) {
    // 业务验证
    if err := s.validateCreateRequest(req); err != nil {
        return nil, err
    }
    
    // 创建用户
    user := &User{
        Username: req.Username,
        Email:    req.Email,
    }
    
    if err := s.repo.Create(ctx, user); err != nil {
        s.logger.Error("Failed to create user", "error", err)
        return nil, err
    }
    
    return user, nil
}

func (s *UserService) validateCreateRequest(req CreateUserRequest) error {
    if req.Username == "" {
        return &ValidationError{Field: "username", Message: "username is required"}
    }
    if req.Email == "" {
        return &ValidationError{Field: "email", Message: "email is required"}
    }
    return nil
}
```

## 开发流程

### 开发步骤

1. **先实现基本功能**：让代码能正常工作，完成核心需求
2. **添加错误处理**：使用 `error` 类型，定义错误变量和类型
3. **优化架构设计**：使用接口、依赖注入等模式
4. **添加并发支持**：如需要，添加 goroutine 和 channel
5. **编写测试**：单元测试和集成测试
6. **代码审查和重构**：改善代码结构和可读性

### 功能开发原则

- 优先实现 MVP，验证核心流程后再完善细节
- 每个功能完成后手动测试验证
- 保持包的独立性和可测试性
- 通过重构逐步改善代码质量
- 及时提交代码并保持提交粒度小
