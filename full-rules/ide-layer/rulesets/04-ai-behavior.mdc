---
description: AI 助手行为偏好
globs:
- '**/*'
alwaysApply: true
tags:
- typescript
- react
version: 1.0.0
author: ai-coding-rules-team
---

# AI 助手行为偏好

## 代码生成

### 生成偏好

- 生成代码时提供清晰的注释说明
- 优先使用项目已有代码风格和模式
- 重要决策提供多个选项并解释利弊

### 代码完整性

- 生成的代码应该是完整可用的
- 包含必要的导入/依赖
- 考虑边界情况和错误处理

## 沟通方式

### 解释风格

- 用简洁清晰的语言解释
- 提供代码片段说明复杂概念
- 提供官方文档链接

### 提问策略

- 遇到不确定的需求时，主动提问澄清
- 提供选项让开发者选择
- 解释每个选项的权衡

## 工作流

### 文件操作

- 所有文件操作前检查文件是否存在
- 修改文件前先读取文件内容
- 批量操作时提供进度提示

### 工具使用

- 使用合适的工具完成任务
- 解释每个工具使用的原因
- 复杂任务分步骤执行

## 多语言处理

### 代码生成的语言选择

- 代码中的标识符（变量名、函数名、类名）优先使用英语
- 技术术语保持英文原形（如 Custom Hooks、Repository Pattern）
- 代码注释根据项目团队习惯选择语言
- 保持与项目现有代码风格一致的命名约定

### 混合语言提示的处理

- 当用户使用中英文混合提示时，优先使用英语实现技术代码
- 对业务逻辑部分，按照用户的语言习惯提供注释
- 技术实现层（API调用、类名、函数名）使用英语关键词
- 在不确定时，主动询问用户注释语言的偏好

## 工具使用建议

### ast-grep 集成（代码验证与重构）

- 在生成代码后，建议使用 ast-grep 验证是否符合项目规范
- 对于框架升级或API迁移，使用 ast-grep 进行批量重构
- 创建自定义的 ast-grep 规则来检查常见的 AI 生成代码问题

**使用场景**：

```bash
# 验证生成的代码是否符合命名规范
sg scan --filter='kind(function_definition)' --filter='regex("^[a-z_]+")'

# 检查是否有未使用的依赖导入
sg scan --pattern='import * from "$A";' --filter='not referenced($A)'
```

### MCP Servers 使用（实时文档查询）

- 推荐使用 Context7 MCP Server 获取最新 API 文档
- 在生成代码前，主动查询官方文档以确保 API 准确性
- 对于复杂的技术决策，使用 MCP Server 获取多个选项的对比信息

**推荐工具**：

- **Context7**：获取最新 API 文档和代码示例
- **Knowledge Graph Memory Server**：跨会话保持项目知识

### 工具组合建议

1. **基础开发流程**：Context7 → AI生成代码 → ast-grep 验证
2. **框架升级场景**：Context7（查新API）→ AI生成代码 → ast-grep（批量替换旧API）
3. **长期项目**：添加 Knowledge Graph Memory Server 保持项目上下文

### Context7 自动使用规则

根据 [Context7 官方指南](https://github.com/upstash/context7)，AI 应该在以下场景**自动**使用 Context7，无需用户明确指示：

#### 自动触发场景

1. **代码生成**（涉及第三方库）
   - 使用任何外部库（React Query、Axios、Lodash 等）
   - 生成 API 调用代码
   - 创建组件或工具函数

2. **设置和配置步骤**
   - 项目初始化配置
   - 工具链设置（ESLint、Prettier、Jest 等）
   - 环境变量配置
   - 构建和部署配置

3. **库/API 文档查询**
   - 解释库的使用方式
   - 查询 API 签名和参数
   - 比较不同版本的功能差异
   - 提供最佳实践示例

4. **框架升级咨询**
   - 提供版本迁移指南
   - 比较新旧版本差异
   - 识别废弃 API

#### 触发条件检查清单

在生成代码或提供技术指导前，检查：

- [ ] 是否涉及第三方库或框架？
- [ ] 是否需要查询 API 文档？
- [ ] 是否需要提供配置步骤？
- [ ] 是否涉及版本特定的功能？

如果以上任一答案为"是"，则自动使用 Context7 查询最新文档。

#### 示例场景

**场景 1：代码生成**

```
用户："帮我写一个 React Query hook 获取用户数据"
→ AI 自动：use context7 "React Query v5 useQuery TypeScript example"
→ AI 生成：基于最新文档的代码
```

**场景 2：配置指导**

```
用户："如何配置 Next.js 的 Tailwind CSS？"
→ AI 自动：use context7 "Next.js Tailwind CSS configuration steps"
→ AI 提供：准确的配置步骤
```

**场景 3：API 查询**

```
用户："Axios 的 interceptors 怎么用？"
→ AI 自动：use context7 "Axios interceptors API documentation"
→ AI 解释：基于官方文档的说明
```

### 本地工具优先使用（Token 优化）

在AI生成代码的过程中，如需进行代码检查和格式化，应优先使用本地安装的工具，而非在对话中生成完整的格式化代码。

**原则**：

- 优先调用本地工具（如 Ruff、Prettier、ESLint）进行代码检查和格式化
- 避免在对话中生成大量格式化后的代码（会增加token消耗）
- 使用工具命令而非代码示例来指导格式化

**使用场景**：

- **代码格式化**：使用 `ruff format`、`prettier --write` 等命令
- **代码检查**：使用 `ruff check`、`eslint` 等命令
- **自动修复**：使用工具的 `--fix` 选项

**示例**：

```bash
# ✅ 推荐：使用本地工具
ruff format file.py
ruff check --fix file.py
prettier --write file.js

# ❌ 不推荐：在对话中生成完整格式化后的代码
（生成大量格式化后的代码会消耗大量token）
```

**理由**：

- 本地工具执行速度快，结果准确
- 减少对话中的token消耗（避免生成大量格式化代码）
- 使用项目配置的工具，确保格式一致性
- 工具命令更简洁，易于理解和执行

### 成本与效果权衡

- **Context7**：强烈推荐（高ROI，低学习成本）
- **ast-grep**：推荐（中等ROI，需要学习成本）
- **本地工具优先**：强烈推荐（减少token消耗，提高效率）
- **Knowledge Graph Memory Server**：推荐用于长期项目（高ROI，高配置成本）
- **Skill 模式**：谨慎推荐（适合标准化流程的团队）
